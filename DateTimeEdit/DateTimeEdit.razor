@using System.Globalization
@inject ILogger<DateTimeEdit> Logger
@inject IJSRuntime Js

<div class="container @(Disabled == true ? "disabled" : "") @(Disabled == null ? "readonly" : "")">
    @if (Mode != EditMode.TimeOnly)
    {
        <input @ref="@(_elements[DatePart.Year])" type="number" class="year" min="1" max="9999" maxlength="4" value="@GetDatePart(DatePart.Year)"
               @oninput="e => HandleInput(e,DatePart.Year)" @onfocus="() => HandleFocus(DatePart.Year)" @onkeyup="e => HandleKeyUp(e, DatePart.Year)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
        <span class="separator">@DateSeparator</span>
        <input @ref="@(_elements[DatePart.Month])" type="number" min="1" max="12" maxlength="2" value="@(GetDatePart(DatePart.Month)?.ToString("00"))"
               @oninput="e => HandleInput(e,DatePart.Month)" @onfocus="() => HandleFocus(DatePart.Month)" @onkeyup="e => HandleKeyUp(e, DatePart.Month)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
        <span class="separator">@DateSeparator</span>
        <input @ref="@(_elements[DatePart.Day])" type="number" min="1" max="31" maxlength="2" value="@(GetDatePart(DatePart.Day)?.ToString("00"))"
               @oninput="e => HandleInput(e,DatePart.Day)" @onfocus="() => HandleFocus(DatePart.Day)" @onkeyup="e => HandleKeyUp(e, DatePart.Day)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
    }

    @if (Mode != EditMode.DateOnly)
    {
        <input @ref="@(_elements[DatePart.Hour])" type="number" min="0" max="23" maxlength="2" class="hour"
               value="@(GetDatePart(DatePart.Hour)?.ToString("00"))"
               @oninput="e => HandleInput(e,DatePart.Hour)" @onfocus="() => HandleFocus(DatePart.Hour)" @onkeyup="e => HandleKeyUp(e, DatePart.Hour)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
        <span class="separator">:</span>
        <input @ref="@(_elements[DatePart.Minute])" type="number" min="0" max="59" maxlength="2"
               value="@(GetDatePart(DatePart.Minute)?.ToString("00"))"
               @oninput="e => HandleInput(e,DatePart.Minute)" @onfocus="() => HandleFocus(DatePart.Minute)" @onkeyup="e => HandleKeyUp(e, DatePart.Minute)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
    }
</div>

@code {

    public enum EditMode
    {
        Datetime,
        DateOnly,
        TimeOnly
    }

    public enum DatePart
    {
        Year,
        Month,
        Day,
        Hour,
        Minute
    }

    [Parameter] public bool? Disabled { get; set; } = false;
    [Parameter] public char DateSeparator { get; set; } = '/';
    [Parameter] public EditMode Mode { get; set; } = EditMode.Datetime;
    [Parameter] public Calendar Calendar { get; set; } = new PersianCalendar();
    [Parameter] public DateTime MinDate { get; set; } = new PersianCalendar().ToDateTime(1300, 1, 1, 0, 0, 0, 0);
    [Parameter] public DateTime MaxDate { get; set; } = DateTime.MaxValue; // Default to the largest date possible

    private DateTime? _value;
    private Dictionary<DatePart, ElementReference> _elements = new();

    private readonly Dictionary<DatePart, int> _dateParts = new();

    [Parameter]
    public DateTime? Value
    {
        get => _value;
        set
        {
            UpdateDateParts(value);
            if (value == null && _value == null || (_value?.Equals(value) ?? false)) return;
            _value = value;
            ValueChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<DateTime?> ValueChanged { get; set; }

    private void UpdateDateParts(DateTime? dateTime)
    {
        if (dateTime.HasValue)
        {
            var value = dateTime.Value;
            _dateParts[DatePart.Year] = Calendar.GetYear(value);
            _dateParts[DatePart.Month] = Calendar.GetMonth(value);
            _dateParts[DatePart.Day] = Calendar.GetDayOfMonth(value);
            _dateParts[DatePart.Hour] = value.Hour;
            _dateParts[DatePart.Minute] = value.Minute;
        }
        else
        {
            _dateParts.Clear();
        }
    }

    private int? GetDatePart(DatePart part)
    {
        return _dateParts.TryGetValue(part, out var value) ? value : null;
    }

    private void UpdateValue()
    {
        if (_dateParts.TryGetValue(DatePart.Year, out var year)
            && _dateParts.TryGetValue(DatePart.Month, out var month)
            && _dateParts.TryGetValue(DatePart.Day, out var day) && IsValidDate(year, month, day))
        {
            var updatedDate = TryCreateDate(year, month, day,
                GetDatePart(DatePart.Hour) ?? _value?.Hour ?? 0, GetDatePart(DatePart.Minute) ?? _value?.Minute ?? 0);
            if (updatedDate.HasValue)
            {
                // Apply min/max restrictions before setting the value
                updatedDate = ApplyMinMaxRestrictions(updatedDate.Value);
                Value = updatedDate;
            }
        }
        else
        {
            Logger.LogWarning("Incomplete date entry, waiting for valid input.");
        }
    }
    private DateTime ApplyMinMaxRestrictions(DateTime value)
    {
        if (value < MinDate)
        {
            return MinDate;
        }

        if (value > MaxDate)
        {
            return MaxDate;
        }

        return value;
    }
    private bool IsValidDate(int? year, int? month, int? day)
    {
        return year.HasValue && month.HasValue && day.HasValue && TryCreateDate(year.Value, month.Value, day.Value).HasValue;
    }

    private DateTime? TryCreateDate(int year, int month, int day, int hour = 0, int minute = 0)
    {
        try
        {
            var _ = Calendar.ToDateTime(year, month, day, hour, minute, 0, 0);
            return _;
        }
        catch
        {
            Logger.LogError($"Invalid Date Attempted: Year={year}, Month={month}, Day={day}");
            return null;
        }

    }
    private async Task HandleInput(ChangeEventArgs e, DatePart part)
    {
        var rawValue = e.Value?.ToString();
        if (int.TryParse(rawValue, out var parsedValue))
        {
            _dateParts[part] = parsedValue;
            var editComplete = part switch
            {
                DatePart.Year => parsedValue.ToString().Length == 4,
                DatePart.Month => parsedValue > 1 || rawValue.Length == 2,
                DatePart.Day => parsedValue > 3 || rawValue.Length == 2,
                _ => rawValue.Length >= 2,
            };

            if (editComplete)
            {
                _dateParts[part] = CoerceValue(parsedValue, part);
                switch (part)
                {
                    case DatePart.Year:
                    case DatePart.Month:
                    case DatePart.Day:
                        var day = GetDatePart(DatePart.Day);
                        if (day.HasValue) _dateParts[DatePart.Day] = CoerceValue(day.Value, DatePart.Day);
                        break;
                }
                await MoveFocus(part);
            }
        }
        else
        {
            _dateParts.Remove(part);
        }

        UpdateValue();
    }


    private async Task MoveFocus(DatePart part, bool forward = true)
    {
        var targetPart = part + (forward ? 1 : -1);
        if (targetPart is < DatePart.Year or > DatePart.Minute) return;
        if (_elements.TryGetValue(targetPart, out var element))
            await element.FocusAsync();
    }

    private int CoerceValue(int value, DatePart part)
    {
        var min = 0;
        var max = 0;
        switch (part)
        {
            case DatePart.Year:
                min = Calendar.GetYear(Calendar.MinSupportedDateTime);
                max = Calendar.GetYear(Calendar.MaxSupportedDateTime);
                break;
            case DatePart.Month:
                min = 1;
                max = 12;
                break;
            case DatePart.Day:
                min = 1;
                max = _dateParts.TryGetValue(DatePart.Year, out var year) && _dateParts.TryGetValue(DatePart.Month, out var month)
                    ? Calendar.GetDaysInMonth(year, month)
                    : 31;
                break;
            case DatePart.Hour:
                min = 0;
                max = 23;
                break;
            case DatePart.Minute:
                min = 0;
                max = 59;
                break;
        }
        return value > max ? max : value < min ? min : value;
    }

    private async Task HandleFocus(DatePart part)
    {
        if (_elements.TryGetValue(part, out var element))
        {
            await Js.InvokeVoidAsync("HTMLInputElement.prototype.select.call", element);
        }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e, DatePart part)
    {
        if (!_elements.TryGetValue(part, out var element)) return;
        var value = await Js.InvokeAsync<string>("Reflect.get", element, "value");
        switch (e.Code)
        {
            case "Backspace" when value.Length == 0:
                await MoveFocus(part, false);
                break;
            case "Enter":
                await MoveFocus(part, !e.ShiftKey);
                break;
        }
    }

}