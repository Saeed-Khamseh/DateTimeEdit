@using System.Globalization
@using System.Runtime.InteropServices.JavaScript
@inject ILogger<DateEdit> Logger
@inject IJSRuntime Js

<div class="container @(Disabled == true ? "disabled" : "") @(Disabled == null ? "readonly" : "")">
    @if (EditMode != EditModes.TimeOnly)
    {
        <input @ref="@(_elements[DatePart.Year])" type="number" class="year" min="1" max="9999" maxlength="4" value="@GetDatePart(DatePart.Year)" @oninput="HandleYearInput"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
        <span class="separator">@DateSeparator</span>
        <input @ref="@(_elements[DatePart.Month])" type="number" min="1" max="12" maxlength="2" value="@(GetDatePart(DatePart.Month)?.ToString("00"))" @oninput="HandleMonthInput"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
        <span class="separator">@DateSeparator</span>
        <input @ref="@(_elements[DatePart.Day])" type="number" min="1" max="31" maxlength="2" value="@(GetDatePart(DatePart.Day)?.ToString("00"))" @oninput="HandleDayInput"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
    }

    @if (EditMode != EditModes.DateOnly)
    {
        <input @ref="@(_elements[DatePart.Hour])" type="number" min="0" max="23" maxlength="2" class="hour" value="@(GetDatePart(DatePart.Hour)?.ToString("00"))" @oninput="HandleHourInput"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
        <span class="separator">:</span>
        <input @ref="@(_elements[DatePart.Minute])" type="number" min="0" max="59" maxlength="2" value="@(GetDatePart(DatePart.Minute)?.ToString("00"))" @oninput="HandleMinuteInput"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
    }
</div>

@code {

    public enum EditModes
    {
        Datetime,
        DateOnly,
        TimeOnly
    }

    public enum DatePart
    {
        Year,
        Month,
        Day,
        Hour,
        Minute
    }

    [Parameter] public bool? Disabled { get; set; } = false;
    [Parameter] public char DateSeparator { get; set; } = '/';
    [Parameter] public EditModes EditMode { get; set; } = EditModes.Datetime;
    [Parameter] public Calendar Calendar { get; set; } = new PersianCalendar();

    private DateTime? _value;
    private DateTime? _lastValidDate;
    private Dictionary<DatePart, ElementReference> _elements = new();

    private readonly Dictionary<DatePart, int> _dateParts = new();

    [Parameter]
    public DateTime? Value
    {
        get => _value;
        set
        {
            if (_value == value) return;
            _value = value;
            UpdateDateParts();
            ValueChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<DateTime?> ValueChanged { get; set; }

    private void UpdateDateParts()
    {
        if (_value.HasValue)
        {
            var value = _value.Value;
            _dateParts[DatePart.Year] = Calendar.GetYear(value);
            _dateParts[DatePart.Month] = Calendar.GetMonth(value);
            _dateParts[DatePart.Day] = Calendar.GetDayOfMonth(value);
            _dateParts[DatePart.Hour] = value.Hour;
            _dateParts[DatePart.Minute] = value.Minute;
            _lastValidDate = value;
        }
        else
        {
            _dateParts.Clear();
        }
    }

    private int? GetDatePart(DatePart part)
    {
        return _dateParts.TryGetValue(part, out var value) ? value : null;
    }

    private void UpdateValue()
    {
        if (_dateParts.TryGetValue(DatePart.Year, out var year)
            && _dateParts.TryGetValue(DatePart.Month, out var month)
            && _dateParts.TryGetValue(DatePart.Day, out var day) && IsValidDate(year, month, day))
        {
            var updatedDate = TryCreateDate(year, month, day,
                GetDatePart(DatePart.Hour) ?? _value?.Hour ?? 0, GetDatePart(DatePart.Minute) ?? _value?.Minute ?? 0);
            if (updatedDate.HasValue)
            {
                _value = updatedDate;
                _lastValidDate = _value;
                ValueChanged.InvokeAsync(_value);
            }
        }
        else
        {
            Logger.LogWarning("Incomplete date entry, waiting for valid input.");
        }
    }

    private bool IsValidDate(int? year, int? month, int? day)
    {
        if (!year.HasValue || !month.HasValue || !day.HasValue)
            return false;
        return TryCreateDate(year.Value, month.Value, day.Value).HasValue;
    }

    private DateTime? TryCreateDate(int year, int month, int day, int hour = 0, int minute = 0)
    {
        try
        {
            var _ = Calendar.ToDateTime(year, month, day, hour, minute, 0, 0);
            return _;
        }
        catch
        {
            Logger.LogError($"Invalid Date Attempted: Year={year}, Month={month}, Day={day}");
            return null;
        }

    }
    private async Task HandleYearInput(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var parsedYear) && parsedYear > 0)
        {
            _dateParts[DatePart.Year] = parsedYear;

            if (parsedYear.ToString().Length == 4)
            {
                await Focus(DatePart.Month);
            }
        }
        else
        {
            _dateParts.Remove(DatePart.Year);
        }

        UpdateValue();
    }

    private async Task HandleMonthInput(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var month) && month > 0)
        {
            _dateParts[DatePart.Month] = month;

            if (month > 1 || month.ToString().Length == 2)
            {
                if (_dateParts.TryGetValue(DatePart.Day, out var day)) _dateParts[DatePart.Day] = CoerceDay(day);
                await Focus(DatePart.Day);
            }
        }
        else
        {
            _dateParts.Remove(DatePart.Month);
        }

        UpdateValue();
    }

    private async Task HandleDayInput(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var day) && day > 0)
        {
            _dateParts[DatePart.Day] = CoerceDay(day);
            if (day > 3 || day.ToString().Length == 2)
            {
                await Focus(DatePart.Hour);
            }
        }
        else
        {
            _dateParts.Remove(DatePart.Day);
        }

        UpdateValue();
    }

    private async Task Focus(DatePart part)
    {
        if (_elements.TryGetValue(part, out var element))
            await element.FocusAsync();
    }

    private async Task HandleHourInput(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var hour))
        {
            _dateParts[DatePart.Hour] = hour;
            if (hour > 2 || hour.ToString().Length == 2)
            {
                await Focus(DatePart.Minute);
            }
        }
        else
        {
            _dateParts.Remove(DatePart.Hour);
        }

        UpdateValue();
    }

    private void HandleMinuteInput(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var parsedMinute))
        {
            _dateParts[DatePart.Minute] = parsedMinute;
        }
        else
        {
            _dateParts.Remove(DatePart.Minute);
        }
        UpdateValue();
    }

    private int CoerceDay(int day)
    {
        if (!_dateParts.TryGetValue(DatePart.Year, out var year) ||
            !_dateParts.TryGetValue(DatePart.Month, out var month)) return day;
        var maxDays = Calendar.GetDaysInMonth(year, month);
        return day > maxDays ? maxDays : day;
    }

}