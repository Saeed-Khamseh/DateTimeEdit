@using System.Globalization
@inject ILogger<DateEdit> Logger
@inject IJSRuntime Js

<div class="container @(Disabled == true ? "disabled" : "") @(Disabled == null ? "readonly" : "")">
    @if (EditMode != EditModes.TimeOnly)
    {
        <input @ref="@(_elements[DatePart.Year])" type="number" class="year" min="1" max="9999" maxlength="4" value="@GetDatePart(DatePart.Year)"
               @oninput="e => HandleInput(e,DatePart.Year)" @onfocus="e => HandleFocus(DatePart.Year)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
        <span class="separator">@DateSeparator</span>
        <input @ref="@(_elements[DatePart.Month])" type="number" min="1" max="12" maxlength="2" value="@(GetDatePart(DatePart.Month)?.ToString("00"))"
               @oninput="e => HandleInput(e,DatePart.Month)" @onfocus="e => HandleFocus(DatePart.Month)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
        <span class="separator">@DateSeparator</span>
        <input @ref="@(_elements[DatePart.Day])" type="number" min="1" max="31" maxlength="2" value="@(GetDatePart(DatePart.Day)?.ToString("00"))"
               @oninput="e => HandleInput(e,DatePart.Day)" @onfocus="e => HandleFocus(DatePart.Day)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
    }

    @if (EditMode != EditModes.DateOnly)
    {
        <input @ref="@(_elements[DatePart.Hour])" type="number" min="0" max="23" maxlength="2" class="hour"
               value="@(GetDatePart(DatePart.Hour)?.ToString("00"))"
               @oninput="e => HandleInput(e,DatePart.Hour)" @onfocus="e => HandleFocus(DatePart.Hour)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
        <span class="separator">:</span>
        <input @ref="@(_elements[DatePart.Minute])" type="number" min="0" max="59" maxlength="2"
               value="@(GetDatePart(DatePart.Minute)?.ToString("00"))"
               @oninput="e => HandleInput(e,DatePart.Minute)" @onfocus="e => HandleFocus(DatePart.Minute)"
               disabled="@(Disabled == true)" readonly="@(Disabled == null)" />
    }
</div>

@code {

    public enum EditModes
    {
        Datetime,
        DateOnly,
        TimeOnly
    }

    public enum DatePart
    {
        Year,
        Month,
        Day,
        Hour,
        Minute
    }

    [Parameter] public bool? Disabled { get; set; } = false;
    [Parameter] public char DateSeparator { get; set; } = '/';
    [Parameter] public EditModes EditMode { get; set; } = EditModes.Datetime;
    [Parameter] public Calendar Calendar { get; set; } = new PersianCalendar();

    private DateTime? _value;
    private DateTime? _lastValidDate;
    private Dictionary<DatePart, ElementReference> _elements = new();

    private readonly Dictionary<DatePart, int> _dateParts = new();

    [Parameter]
    public DateTime? Value
    {
        get => _value;
        set
        {
            if (_value == value) return;
            _value = value;
            UpdateDateParts();
            ValueChanged.InvokeAsync(value);
        }
    }

    [Parameter] public EventCallback<DateTime?> ValueChanged { get; set; }

    private void UpdateDateParts()
    {
        if (_value.HasValue)
        {
            var value = _value.Value;
            _dateParts[DatePart.Year] = Calendar.GetYear(value);
            _dateParts[DatePart.Month] = Calendar.GetMonth(value);
            _dateParts[DatePart.Day] = Calendar.GetDayOfMonth(value);
            _dateParts[DatePart.Hour] = value.Hour;
            _dateParts[DatePart.Minute] = value.Minute;
            _lastValidDate = value;
        }
        else
        {
            _dateParts.Clear();
        }
    }

    private int? GetDatePart(DatePart part)
    {
        return _dateParts.TryGetValue(part, out var value) ? value : null;
    }

    private void UpdateValue()
    {
        if (_dateParts.TryGetValue(DatePart.Year, out var year)
            && _dateParts.TryGetValue(DatePart.Month, out var month)
            && _dateParts.TryGetValue(DatePart.Day, out var day) && IsValidDate(year, month, day))
        {
            var updatedDate = TryCreateDate(year, month, day,
                GetDatePart(DatePart.Hour) ?? _value?.Hour ?? 0, GetDatePart(DatePart.Minute) ?? _value?.Minute ?? 0);
            if (updatedDate.HasValue)
            {
                _value = updatedDate;
                _lastValidDate = _value;
                ValueChanged.InvokeAsync(_value);
            }
        }
        else
        {
            Logger.LogWarning("Incomplete date entry, waiting for valid input.");
        }
    }

    private bool IsValidDate(int? year, int? month, int? day)
    {
        return year.HasValue && month.HasValue && day.HasValue && TryCreateDate(year.Value, month.Value, day.Value).HasValue;
    }

    private DateTime? TryCreateDate(int year, int month, int day, int hour = 0, int minute = 0)
    {
        try
        {
            var _ = Calendar.ToDateTime(year, month, day, hour, minute, 0, 0);
            return _;
        }
        catch
        {
            Logger.LogError($"Invalid Date Attempted: Year={year}, Month={month}, Day={day}");
            return null;
        }

    }
    private async Task HandleInput(ChangeEventArgs e, DatePart part)
    {
        var rawValue = e.Value?.ToString();
        if (int.TryParse(rawValue, out var parsedValue))
        {
            _dateParts[part] = parsedValue;
            var editComplete = part switch
            {
                DatePart.Year => parsedValue.ToString().Length == 4,
                DatePart.Month => parsedValue > 1 || rawValue.Length == 2,
                DatePart.Day => parsedValue > 3 || rawValue.Length == 2,
                _ => rawValue.Length >= 2,
            };

            if (editComplete)
            {
                _dateParts[part] = CoerceValue(parsedValue, part);
                switch (part)
                {
                    case DatePart.Year:
                    case DatePart.Month:
                    case DatePart.Day:
                        var day = GetDatePart(DatePart.Day);
                        if (day.HasValue) _dateParts[DatePart.Day] = CoerceValue(day.Value, DatePart.Day);
                        break;
                }
                var nextPart = (DatePart)((int)part + 1);
                var max = EditMode == EditModes.DateOnly ? DatePart.Day : DatePart.Minute;
                if (nextPart <= max) await Focus(nextPart);
            }
        }
        else
        {
            _dateParts.Remove(part);
        }

        UpdateValue();
    }


    private async Task Focus(DatePart part)
    {
        if (_elements.TryGetValue(part, out var element))
            await element.FocusAsync();
    }

    private int CoerceValue(int value, DatePart part)
    {
        var min = 0;
        var max = 0;
        switch (part)
        {
            case DatePart.Year:
                min = Calendar.GetYear(Calendar.MinSupportedDateTime);
                max = Calendar.GetYear(Calendar.MaxSupportedDateTime);
                break;
            case DatePart.Month:
                min = 1;
                max = 12;
                break;
            case DatePart.Day:
                min = 1;
                max = _dateParts.TryGetValue(DatePart.Year, out var year) && _dateParts.TryGetValue(DatePart.Month, out var month)
                    ? Calendar.GetDaysInMonth(year, month)
                    : 31;
                break;
            case DatePart.Hour:
                min = 0;
                max = 23;
                break;
            case DatePart.Minute:
                min = 0;
                max = 59;
                break;
        }
        return value > max ? max : value < min ? min : value;
    }

    private async Task HandleFocus(DatePart part)
    {
        if (_elements.TryGetValue(part, out var element))
        {
            await Js.InvokeVoidAsync("HTMLInputElement.prototype.select.call", element);
        }
    }

}